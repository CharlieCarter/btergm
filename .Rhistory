library(btergm)
library(statnet)
install_github("desmarais-lab/btergm")
library(xergm)
library(devtools)
# install.packages("randomNames", dependencies = TRUE)
library("randomNames")
set.seed(10)
data("knecht", package = "xergm.common")
randomnames <- unique(randomNames(100, which.names = "first", sample.with.replacement = FALSE))[1:26] # generate 26 names
## roundabout way to weed out duplicated names (probably bug in randomNames)
for (i in 1:length(friendship)) {
rownames(friendship[[i]]) <- randomnames
colnames(friendship[[i]]) <- randomnames
}
friendship <- handleMissings(friendship, na = 10, method = "remove") # 10 is value assigned to missing nodes
friendship <- handleMissings(friendship, na = NA, method = "remove") # remove as well to have more missing nodes for sake of illustration
# This creates network object and sets attributes and adjusts dimensions:
for (i in 1:length(friendship)) {
friendship[[i]] <- network(friendship[[i]]) # create network object
idegsqrt <- sqrt(degree(friendship[[i]], cmode = "indegree")) # create attribute
friendship[[i]] <- set.vertex.attribute(friendship[[i]], "idegsqrt", idegsqrt) # set attribute
odegsqrt <- sqrt(degree(friendship[[i]], cmode = "outdegree")) # create attribute
friendship[[i]] <- set.vertex.attribute(friendship[[i]], "odegsqrt", odegsqrt) # set attribute
}
sapply(friendship, network.size) # print dimensions
## Time dependent model
model.names <- mtergm(friendship ~ edges + mutual + ttriple +
transitiveties + ctriple + nodeicov("idegsqrt") +
nodeicov("odegsqrt") + nodeocov("odegsqrt") +
delrecip + memory(type = "stability"),
control = control.ergm(MCMC.samplesize = 2000, MCMC.interval = 1000))
# summary(model.names)
randomnames[3+1] # pick first node of interest (node 2, John, is missing at t1, so indices have already shifted)
randomnames[4+1] # pick second node of interest
edge.info <- edgeprob(model.names) # I checked names/indices by comparing the edge probabilities but this would not be feasible on a larger scale
interpret(model.names, type = "tie", i = 3, j = 4, t = 1) # nodes 3 and 4 at t = 1
interpret(model.names, type = "tie", i = "Megan", j = "Rifat", t = 1) # with names from above, same probability, all good
interpret(model.names, type = "tie", i = 3, j = 4, t = 3) # indices remain the same, later time period
interpret(model.names, type = "tie", i = "Megan", j = "Rifat", t = 3) # not same probability, indicating that node indices and names are not in sync
head(edgeprob(model.names)) # would be great to have node names included here
names(model.names)
nodel.names
model.names
attributes(model.names)
names(attributes(model.names))
attributes(model.names)$aci
attributes(model.names)$aic
model.names@aic
attributes(model.names)$loglik
?mtergm
mtergm
?edgeprob
library(btergm)
?edgeprob
library(btergm)
?edgeprob
?ergm
single.impute.dyads
0.61*0.38
